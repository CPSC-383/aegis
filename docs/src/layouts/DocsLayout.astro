---
import type { InferEntrySchema } from "astro:content";
import type { MarkdownHeading } from "astro";
import MainLayout from "./MainLayout.astro";
import TableOfContent from "@/components/TableOfContent";
import TopOverlay from "@/components/TopOverlay";

interface Props extends InferEntrySchema<"docs"> {
  headings: MarkdownHeading[];
}

const { title, description, headings } = Astro.props;
---

<MainLayout>
  <TopOverlay />
  <div class="max-w-[872px]">
    <section class="mt-16 sm:mt-24 sm:font-light lg:mt-32">
      <h1 class="text-[clamp(1.875rem,5vw,2.25rem)] font-bold">
        {title}
      </h1>
      <h3 class="mt-2 text-zinc-400 max-sm:text-sm">
        {description}
      </h3>
    </section>
    <section class="flex mt-8 gap-16">
      <article
        id="article"
        class:list={[
          "prose prose-invert max-w-none max-sm:prose-sm",
          "prose-headings:font-display prose-headings:scroll-m-16 sm:prose-headings:scroll-m-24",
        ]}
      >
        <slot />
      </article>
      <aside class="w-60 shrink-0 max-lg:hidden">
        <TableOfContent headings={headings} className="sticky top-32" />
      </aside>
    </section>
  </div>
</MainLayout>

<script>
  const handleHeadingIntersection = () => {
    console.log("in handle heading");
    const observerOptions: IntersectionObserverInit = {
      root: null,
      rootMargin: "0px 0px -85% 0px",
      threshold: 0,
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) return;

        const id = entry.target.getAttribute("id");
        const link = document.querySelector(`li > a[href="#${id}"]`);
        const textStyle = "text-zinc-300";

        document
          .querySelectorAll(`.${textStyle}`)
          .forEach((item) => item.classList.remove(textStyle));

        link?.classList.add(textStyle);
        console.log(link);
      });
    }, observerOptions);

    document.querySelectorAll("h2[id], h3[id], h4[id]").forEach((heading) => {
      observer.observe(heading);
    });
  };

  handleHeadingIntersection();
</script>
