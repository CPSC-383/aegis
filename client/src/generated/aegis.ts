// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "aegis.proto" (package "aegis", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
/**
 * Basic types
 *
 * @generated from protobuf message aegis.Location
 */
export interface Location {
    /**
     * @generated from protobuf field: int32 x = 1
     */
    x: number
    /**
     * @generated from protobuf field: int32 y = 2
     */
    y: number
}
/**
 * @generated from protobuf message aegis.AgentID
 */
export interface AgentID {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number
    /**
     * @generated from protobuf field: int32 gid = 2
     */
    gid: number
}
/**
 * World objects
 *
 * @generated from protobuf message aegis.Survivor
 */
export interface Survivor {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number
    /**
     * @generated from protobuf field: int32 state = 2
     */
    state: number // 0 = alive, 1 = dead
}
/**
 * @generated from protobuf message aegis.Rubble
 */
export interface Rubble {
    /**
     * @generated from protobuf field: int32 move_cost = 1
     */
    moveCost: number
}
/**
 * @generated from protobuf message aegis.Cell
 */
export interface Cell {
    /**
     * @generated from protobuf field: aegis.Location location = 1
     */
    location?: Location
    /**
     * @generated from protobuf field: int32 move_cost = 2
     */
    moveCost: number
    /**
     * @generated from protobuf field: repeated aegis.AgentID agent_ids = 3
     */
    agentIds: AgentID[]
    /**
     * @generated from protobuf field: bool has_survivors = 4
     */
    hasSurvivors: boolean
    /**
     * @generated from protobuf oneof: top_layer
     */
    topLayer:
        | {
              oneofKind: 'survivor'
              /**
               * @generated from protobuf field: aegis.Survivor survivor = 5
               */
              survivor: Survivor
          }
        | {
              oneofKind: 'rubble'
              /**
               * @generated from protobuf field: aegis.Rubble rubble = 6
               */
              rubble: Rubble
          }
        | {
              oneofKind: undefined
          }
}
/**
 * World state
 *
 * @generated from protobuf message aegis.WorldState
 */
export interface WorldState {
    /**
     * @generated from protobuf field: int32 width = 1
     */
    width: number
    /**
     * @generated from protobuf field: int32 height = 2
     */
    height: number
    /**
     * @generated from protobuf field: repeated aegis.Cell cells = 3
     */
    cells: Cell[]
    /**
     * @generated from protobuf field: repeated aegis.Agent agents = 4
     */
    agents: Agent[]
    /**
     * @generated from protobuf field: repeated aegis.Survivor survivors = 5
     */
    survivors: Survivor[]
}
/**
 * Agent information
 *
 * @generated from protobuf message aegis.Agent
 */
export interface Agent {
    /**
     * @generated from protobuf field: aegis.AgentID agent_id = 1
     */
    agentId?: AgentID
    /**
     * @generated from protobuf field: aegis.Location location = 2
     */
    location?: Location
    /**
     * @generated from protobuf field: int32 energy_level = 3
     */
    energyLevel: number
    /**
     * @generated from protobuf field: int32 steps_taken = 4
     */
    stepsTaken: number
}
/**
 * Group data for scoring
 *
 * @generated from protobuf message aegis.GroupData
 */
export interface GroupData {
    /**
     * @generated from protobuf field: int32 gid = 1
     */
    gid: number
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string
    /**
     * @generated from protobuf field: int32 score = 3
     */
    score: number
    /**
     * @generated from protobuf field: int32 number_saved = 4
     */
    numberSaved: number
    /**
     * @generated from protobuf field: int32 number_predicted_right = 5
     */
    numberPredictedRight: number
    /**
     * @generated from protobuf field: int32 number_predicted_wrong = 6
     */
    numberPredictedWrong: number
}
/**
 * Round update
 *
 * @generated from protobuf message aegis.RoundUpdate
 */
export interface RoundUpdate {
    /**
     * @generated from protobuf field: int32 round = 1
     */
    round: number
    /**
     * @generated from protobuf field: aegis.WorldState world = 2
     */
    world?: WorldState
    /**
     * @generated from protobuf field: repeated aegis.GroupData groups = 3
     */
    groups: GroupData[]
}
/**
 * Simulation state
 *
 * @generated from protobuf message aegis.SimulationState
 */
export interface SimulationState {
    /**
     * @generated from protobuf field: int32 current_round = 1
     */
    currentRound: number
    /**
     * @generated from protobuf field: int32 max_rounds = 2
     */
    maxRounds: number
    /**
     * @generated from protobuf field: bool is_round_zero = 3
     */
    isRoundZero: boolean
}
/**
 * World statistics
 *
 * @generated from protobuf message aegis.WorldStats
 */
export interface WorldStats {
    /**
     * @generated from protobuf field: int32 agents_alive = 1
     */
    agentsAlive: number
    /**
     * @generated from protobuf field: int32 agents_dead = 2
     */
    agentsDead: number
    /**
     * @generated from protobuf field: int32 total_survivors = 3
     */
    totalSurvivors: number
    /**
     * @generated from protobuf field: int32 survivors_saved = 4
     */
    survivorsSaved: number
    /**
     * @generated from protobuf field: int32 steps_taken = 5
     */
    stepsTaken: number
}
/**
 * Group statistics for UI display
 *
 * @generated from protobuf message aegis.GroupStats
 */
export interface GroupStats {
    /**
     * @generated from protobuf field: int32 gid = 1
     */
    gid: number
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string
    /**
     * @generated from protobuf field: int32 score = 3
     */
    score: number
    /**
     * @generated from protobuf field: int32 survivors_saved = 4
     */
    survivorsSaved: number
    /**
     * @generated from protobuf field: int32 correct_predictions = 5
     */
    correctPredictions: number
    /**
     * @generated from protobuf field: int32 incorrect_predictions = 6
     */
    incorrectPredictions: number
}
/**
 * Round data
 *
 * @generated from protobuf message aegis.RoundData
 */
export interface RoundData {
    /**
     * @generated from protobuf field: string event_type = 1
     */
    eventType: string
    /**
     * @generated from protobuf field: int32 round = 2
     */
    round: number
    /**
     * @generated from protobuf field: aegis.WorldState after_world = 3
     */
    afterWorld?: WorldState
    /**
     * @generated from protobuf field: repeated aegis.GroupData groups_data = 4
     */
    groupsData: GroupData[]
}
/**
 * Simulation events
 *
 * Empty message for completion event
 *
 * @generated from protobuf message aegis.SimulationComplete
 */
export interface SimulationComplete {}
/**
 * Main event wrapper
 *
 * @generated from protobuf message aegis.SimulationEvent
 */
export interface SimulationEvent {
    /**
     * @generated from protobuf oneof: event
     */
    event:
        | {
              oneofKind: 'worldInit'
              /**
               * @generated from protobuf field: aegis.WorldState world_init = 1
               */
              worldInit: WorldState
          }
        | {
              oneofKind: 'roundUpdate'
              /**
               * @generated from protobuf field: aegis.RoundUpdate round_update = 2
               */
              roundUpdate: RoundUpdate
          }
        | {
              oneofKind: 'complete'
              /**
               * @generated from protobuf field: aegis.SimulationComplete complete = 3
               */
              complete: SimulationComplete
          }
        | {
              oneofKind: undefined
          }
}
// @generated message type with reflection information, may provide speed optimized methods
class Location$Type extends MessageType<Location> {
    constructor() {
        super('aegis.Location', [
            { no: 1, name: 'x', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: 'y', kind: 'scalar', T: 5 /*ScalarType.INT32*/ }
        ])
    }
    create(value?: PartialMessage<Location>): Location {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.x = 0
        message.y = 0
        if (value !== undefined) reflectionMergePartial<Location>(this, message, value)
        return message
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Location): Location {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* int32 x */ 1:
                    message.x = reader.int32()
                    break
                case /* int32 y */ 2:
                    message.y = reader.int32()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
            }
        }
        return message
    }
    internalBinaryWrite(message: Location, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 x = 1; */
        if (message.x !== 0) writer.tag(1, WireType.Varint).int32(message.x)
        /* int32 y = 2; */
        if (message.y !== 0) writer.tag(2, WireType.Varint).int32(message.y)
        let u = options.writeUnknownFields
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
        return writer
    }
}
/**
 * @generated MessageType for protobuf message aegis.Location
 */
export const Location = new Location$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AgentID$Type extends MessageType<AgentID> {
    constructor() {
        super('aegis.AgentID', [
            { no: 1, name: 'id', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: 'gid', kind: 'scalar', T: 5 /*ScalarType.INT32*/ }
        ])
    }
    create(value?: PartialMessage<AgentID>): AgentID {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.id = 0
        message.gid = 0
        if (value !== undefined) reflectionMergePartial<AgentID>(this, message, value)
        return message
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgentID): AgentID {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32()
                    break
                case /* int32 gid */ 2:
                    message.gid = reader.int32()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
            }
        }
        return message
    }
    internalBinaryWrite(message: AgentID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0) writer.tag(1, WireType.Varint).int32(message.id)
        /* int32 gid = 2; */
        if (message.gid !== 0) writer.tag(2, WireType.Varint).int32(message.gid)
        let u = options.writeUnknownFields
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
        return writer
    }
}
/**
 * @generated MessageType for protobuf message aegis.AgentID
 */
export const AgentID = new AgentID$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Survivor$Type extends MessageType<Survivor> {
    constructor() {
        super('aegis.Survivor', [
            { no: 1, name: 'id', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: 'state', kind: 'scalar', T: 5 /*ScalarType.INT32*/ }
        ])
    }
    create(value?: PartialMessage<Survivor>): Survivor {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.id = 0
        message.state = 0
        if (value !== undefined) reflectionMergePartial<Survivor>(this, message, value)
        return message
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Survivor): Survivor {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32()
                    break
                case /* int32 state */ 2:
                    message.state = reader.int32()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
            }
        }
        return message
    }
    internalBinaryWrite(message: Survivor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0) writer.tag(1, WireType.Varint).int32(message.id)
        /* int32 state = 2; */
        if (message.state !== 0) writer.tag(2, WireType.Varint).int32(message.state)
        let u = options.writeUnknownFields
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
        return writer
    }
}
/**
 * @generated MessageType for protobuf message aegis.Survivor
 */
export const Survivor = new Survivor$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Rubble$Type extends MessageType<Rubble> {
    constructor() {
        super('aegis.Rubble', [{ no: 1, name: 'move_cost', kind: 'scalar', T: 5 /*ScalarType.INT32*/ }])
    }
    create(value?: PartialMessage<Rubble>): Rubble {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.moveCost = 0
        if (value !== undefined) reflectionMergePartial<Rubble>(this, message, value)
        return message
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Rubble): Rubble {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* int32 move_cost */ 1:
                    message.moveCost = reader.int32()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
            }
        }
        return message
    }
    internalBinaryWrite(message: Rubble, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 move_cost = 1; */
        if (message.moveCost !== 0) writer.tag(1, WireType.Varint).int32(message.moveCost)
        let u = options.writeUnknownFields
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
        return writer
    }
}
/**
 * @generated MessageType for protobuf message aegis.Rubble
 */
export const Rubble = new Rubble$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Cell$Type extends MessageType<Cell> {
    constructor() {
        super('aegis.Cell', [
            { no: 1, name: 'location', kind: 'message', T: () => Location },
            { no: 2, name: 'move_cost', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: 'agent_ids', kind: 'message', repeat: 2 /*RepeatType.UNPACKED*/, T: () => AgentID },
            { no: 4, name: 'has_survivors', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: 'survivor', kind: 'message', oneof: 'topLayer', T: () => Survivor },
            { no: 6, name: 'rubble', kind: 'message', oneof: 'topLayer', T: () => Rubble }
        ])
    }
    create(value?: PartialMessage<Cell>): Cell {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.moveCost = 0
        message.agentIds = []
        message.hasSurvivors = false
        message.topLayer = { oneofKind: undefined }
        if (value !== undefined) reflectionMergePartial<Cell>(this, message, value)
        return message
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cell): Cell {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* aegis.Location location */ 1:
                    message.location = Location.internalBinaryRead(reader, reader.uint32(), options, message.location)
                    break
                case /* int32 move_cost */ 2:
                    message.moveCost = reader.int32()
                    break
                case /* repeated aegis.AgentID agent_ids */ 3:
                    message.agentIds.push(AgentID.internalBinaryRead(reader, reader.uint32(), options))
                    break
                case /* bool has_survivors */ 4:
                    message.hasSurvivors = reader.bool()
                    break
                case /* aegis.Survivor survivor */ 5:
                    message.topLayer = {
                        oneofKind: 'survivor',
                        survivor: Survivor.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.topLayer as any).survivor
                        )
                    }
                    break
                case /* aegis.Rubble rubble */ 6:
                    message.topLayer = {
                        oneofKind: 'rubble',
                        rubble: Rubble.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.topLayer as any).rubble
                        )
                    }
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
            }
        }
        return message
    }
    internalBinaryWrite(message: Cell, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* aegis.Location location = 1; */
        if (message.location)
            Location.internalBinaryWrite(
                message.location,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* int32 move_cost = 2; */
        if (message.moveCost !== 0) writer.tag(2, WireType.Varint).int32(message.moveCost)
        /* repeated aegis.AgentID agent_ids = 3; */
        for (let i = 0; i < message.agentIds.length; i++)
            AgentID.internalBinaryWrite(
                message.agentIds[i],
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* bool has_survivors = 4; */
        if (message.hasSurvivors !== false) writer.tag(4, WireType.Varint).bool(message.hasSurvivors)
        /* aegis.Survivor survivor = 5; */
        if (message.topLayer.oneofKind === 'survivor')
            Survivor.internalBinaryWrite(
                message.topLayer.survivor,
                writer.tag(5, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* aegis.Rubble rubble = 6; */
        if (message.topLayer.oneofKind === 'rubble')
            Rubble.internalBinaryWrite(
                message.topLayer.rubble,
                writer.tag(6, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
        return writer
    }
}
/**
 * @generated MessageType for protobuf message aegis.Cell
 */
export const Cell = new Cell$Type()
// @generated message type with reflection information, may provide speed optimized methods
class WorldState$Type extends MessageType<WorldState> {
    constructor() {
        super('aegis.WorldState', [
            { no: 1, name: 'width', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: 'height', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: 'cells', kind: 'message', repeat: 2 /*RepeatType.UNPACKED*/, T: () => Cell },
            { no: 4, name: 'agents', kind: 'message', repeat: 2 /*RepeatType.UNPACKED*/, T: () => Agent },
            { no: 5, name: 'survivors', kind: 'message', repeat: 2 /*RepeatType.UNPACKED*/, T: () => Survivor }
        ])
    }
    create(value?: PartialMessage<WorldState>): WorldState {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.width = 0
        message.height = 0
        message.cells = []
        message.agents = []
        message.survivors = []
        if (value !== undefined) reflectionMergePartial<WorldState>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: WorldState
    ): WorldState {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* int32 width */ 1:
                    message.width = reader.int32()
                    break
                case /* int32 height */ 2:
                    message.height = reader.int32()
                    break
                case /* repeated aegis.Cell cells */ 3:
                    message.cells.push(Cell.internalBinaryRead(reader, reader.uint32(), options))
                    break
                case /* repeated aegis.Agent agents */ 4:
                    message.agents.push(Agent.internalBinaryRead(reader, reader.uint32(), options))
                    break
                case /* repeated aegis.Survivor survivors */ 5:
                    message.survivors.push(Survivor.internalBinaryRead(reader, reader.uint32(), options))
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
            }
        }
        return message
    }
    internalBinaryWrite(message: WorldState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 width = 1; */
        if (message.width !== 0) writer.tag(1, WireType.Varint).int32(message.width)
        /* int32 height = 2; */
        if (message.height !== 0) writer.tag(2, WireType.Varint).int32(message.height)
        /* repeated aegis.Cell cells = 3; */
        for (let i = 0; i < message.cells.length; i++)
            Cell.internalBinaryWrite(message.cells[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join()
        /* repeated aegis.Agent agents = 4; */
        for (let i = 0; i < message.agents.length; i++)
            Agent.internalBinaryWrite(message.agents[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join()
        /* repeated aegis.Survivor survivors = 5; */
        for (let i = 0; i < message.survivors.length; i++)
            Survivor.internalBinaryWrite(
                message.survivors[i],
                writer.tag(5, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
        return writer
    }
}
/**
 * @generated MessageType for protobuf message aegis.WorldState
 */
export const WorldState = new WorldState$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Agent$Type extends MessageType<Agent> {
    constructor() {
        super('aegis.Agent', [
            { no: 1, name: 'agent_id', kind: 'message', T: () => AgentID },
            { no: 2, name: 'location', kind: 'message', T: () => Location },
            { no: 3, name: 'energy_level', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: 'steps_taken', kind: 'scalar', T: 5 /*ScalarType.INT32*/ }
        ])
    }
    create(value?: PartialMessage<Agent>): Agent {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.energyLevel = 0
        message.stepsTaken = 0
        if (value !== undefined) reflectionMergePartial<Agent>(this, message, value)
        return message
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Agent): Agent {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* aegis.AgentID agent_id */ 1:
                    message.agentId = AgentID.internalBinaryRead(reader, reader.uint32(), options, message.agentId)
                    break
                case /* aegis.Location location */ 2:
                    message.location = Location.internalBinaryRead(reader, reader.uint32(), options, message.location)
                    break
                case /* int32 energy_level */ 3:
                    message.energyLevel = reader.int32()
                    break
                case /* int32 steps_taken */ 4:
                    message.stepsTaken = reader.int32()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
            }
        }
        return message
    }
    internalBinaryWrite(message: Agent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* aegis.AgentID agent_id = 1; */
        if (message.agentId)
            AgentID.internalBinaryWrite(message.agentId, writer.tag(1, WireType.LengthDelimited).fork(), options).join()
        /* aegis.Location location = 2; */
        if (message.location)
            Location.internalBinaryWrite(
                message.location,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* int32 energy_level = 3; */
        if (message.energyLevel !== 0) writer.tag(3, WireType.Varint).int32(message.energyLevel)
        /* int32 steps_taken = 4; */
        if (message.stepsTaken !== 0) writer.tag(4, WireType.Varint).int32(message.stepsTaken)
        let u = options.writeUnknownFields
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
        return writer
    }
}
/**
 * @generated MessageType for protobuf message aegis.Agent
 */
export const Agent = new Agent$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GroupData$Type extends MessageType<GroupData> {
    constructor() {
        super('aegis.GroupData', [
            { no: 1, name: 'gid', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: 'score', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: 'number_saved', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: 'number_predicted_right', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: 'number_predicted_wrong', kind: 'scalar', T: 5 /*ScalarType.INT32*/ }
        ])
    }
    create(value?: PartialMessage<GroupData>): GroupData {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.gid = 0
        message.name = ''
        message.score = 0
        message.numberSaved = 0
        message.numberPredictedRight = 0
        message.numberPredictedWrong = 0
        if (value !== undefined) reflectionMergePartial<GroupData>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GroupData
    ): GroupData {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* int32 gid */ 1:
                    message.gid = reader.int32()
                    break
                case /* string name */ 2:
                    message.name = reader.string()
                    break
                case /* int32 score */ 3:
                    message.score = reader.int32()
                    break
                case /* int32 number_saved */ 4:
                    message.numberSaved = reader.int32()
                    break
                case /* int32 number_predicted_right */ 5:
                    message.numberPredictedRight = reader.int32()
                    break
                case /* int32 number_predicted_wrong */ 6:
                    message.numberPredictedWrong = reader.int32()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
            }
        }
        return message
    }
    internalBinaryWrite(message: GroupData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 gid = 1; */
        if (message.gid !== 0) writer.tag(1, WireType.Varint).int32(message.gid)
        /* string name = 2; */
        if (message.name !== '') writer.tag(2, WireType.LengthDelimited).string(message.name)
        /* int32 score = 3; */
        if (message.score !== 0) writer.tag(3, WireType.Varint).int32(message.score)
        /* int32 number_saved = 4; */
        if (message.numberSaved !== 0) writer.tag(4, WireType.Varint).int32(message.numberSaved)
        /* int32 number_predicted_right = 5; */
        if (message.numberPredictedRight !== 0) writer.tag(5, WireType.Varint).int32(message.numberPredictedRight)
        /* int32 number_predicted_wrong = 6; */
        if (message.numberPredictedWrong !== 0) writer.tag(6, WireType.Varint).int32(message.numberPredictedWrong)
        let u = options.writeUnknownFields
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
        return writer
    }
}
/**
 * @generated MessageType for protobuf message aegis.GroupData
 */
export const GroupData = new GroupData$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RoundUpdate$Type extends MessageType<RoundUpdate> {
    constructor() {
        super('aegis.RoundUpdate', [
            { no: 1, name: 'round', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: 'world', kind: 'message', T: () => WorldState },
            { no: 3, name: 'groups', kind: 'message', repeat: 2 /*RepeatType.UNPACKED*/, T: () => GroupData }
        ])
    }
    create(value?: PartialMessage<RoundUpdate>): RoundUpdate {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.round = 0
        message.groups = []
        if (value !== undefined) reflectionMergePartial<RoundUpdate>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RoundUpdate
    ): RoundUpdate {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* int32 round */ 1:
                    message.round = reader.int32()
                    break
                case /* aegis.WorldState world */ 2:
                    message.world = WorldState.internalBinaryRead(reader, reader.uint32(), options, message.world)
                    break
                case /* repeated aegis.GroupData groups */ 3:
                    message.groups.push(GroupData.internalBinaryRead(reader, reader.uint32(), options))
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
            }
        }
        return message
    }
    internalBinaryWrite(message: RoundUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 round = 1; */
        if (message.round !== 0) writer.tag(1, WireType.Varint).int32(message.round)
        /* aegis.WorldState world = 2; */
        if (message.world)
            WorldState.internalBinaryWrite(
                message.world,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* repeated aegis.GroupData groups = 3; */
        for (let i = 0; i < message.groups.length; i++)
            GroupData.internalBinaryWrite(
                message.groups[i],
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
        return writer
    }
}
/**
 * @generated MessageType for protobuf message aegis.RoundUpdate
 */
export const RoundUpdate = new RoundUpdate$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SimulationState$Type extends MessageType<SimulationState> {
    constructor() {
        super('aegis.SimulationState', [
            { no: 1, name: 'current_round', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: 'max_rounds', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: 'is_round_zero', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ }
        ])
    }
    create(value?: PartialMessage<SimulationState>): SimulationState {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.currentRound = 0
        message.maxRounds = 0
        message.isRoundZero = false
        if (value !== undefined) reflectionMergePartial<SimulationState>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SimulationState
    ): SimulationState {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* int32 current_round */ 1:
                    message.currentRound = reader.int32()
                    break
                case /* int32 max_rounds */ 2:
                    message.maxRounds = reader.int32()
                    break
                case /* bool is_round_zero */ 3:
                    message.isRoundZero = reader.bool()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
            }
        }
        return message
    }
    internalBinaryWrite(message: SimulationState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 current_round = 1; */
        if (message.currentRound !== 0) writer.tag(1, WireType.Varint).int32(message.currentRound)
        /* int32 max_rounds = 2; */
        if (message.maxRounds !== 0) writer.tag(2, WireType.Varint).int32(message.maxRounds)
        /* bool is_round_zero = 3; */
        if (message.isRoundZero !== false) writer.tag(3, WireType.Varint).bool(message.isRoundZero)
        let u = options.writeUnknownFields
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
        return writer
    }
}
/**
 * @generated MessageType for protobuf message aegis.SimulationState
 */
export const SimulationState = new SimulationState$Type()
// @generated message type with reflection information, may provide speed optimized methods
class WorldStats$Type extends MessageType<WorldStats> {
    constructor() {
        super('aegis.WorldStats', [
            { no: 1, name: 'agents_alive', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: 'agents_dead', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: 'total_survivors', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: 'survivors_saved', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: 'steps_taken', kind: 'scalar', T: 5 /*ScalarType.INT32*/ }
        ])
    }
    create(value?: PartialMessage<WorldStats>): WorldStats {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.agentsAlive = 0
        message.agentsDead = 0
        message.totalSurvivors = 0
        message.survivorsSaved = 0
        message.stepsTaken = 0
        if (value !== undefined) reflectionMergePartial<WorldStats>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: WorldStats
    ): WorldStats {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* int32 agents_alive */ 1:
                    message.agentsAlive = reader.int32()
                    break
                case /* int32 agents_dead */ 2:
                    message.agentsDead = reader.int32()
                    break
                case /* int32 total_survivors */ 3:
                    message.totalSurvivors = reader.int32()
                    break
                case /* int32 survivors_saved */ 4:
                    message.survivorsSaved = reader.int32()
                    break
                case /* int32 steps_taken */ 5:
                    message.stepsTaken = reader.int32()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
            }
        }
        return message
    }
    internalBinaryWrite(message: WorldStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 agents_alive = 1; */
        if (message.agentsAlive !== 0) writer.tag(1, WireType.Varint).int32(message.agentsAlive)
        /* int32 agents_dead = 2; */
        if (message.agentsDead !== 0) writer.tag(2, WireType.Varint).int32(message.agentsDead)
        /* int32 total_survivors = 3; */
        if (message.totalSurvivors !== 0) writer.tag(3, WireType.Varint).int32(message.totalSurvivors)
        /* int32 survivors_saved = 4; */
        if (message.survivorsSaved !== 0) writer.tag(4, WireType.Varint).int32(message.survivorsSaved)
        /* int32 steps_taken = 5; */
        if (message.stepsTaken !== 0) writer.tag(5, WireType.Varint).int32(message.stepsTaken)
        let u = options.writeUnknownFields
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
        return writer
    }
}
/**
 * @generated MessageType for protobuf message aegis.WorldStats
 */
export const WorldStats = new WorldStats$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GroupStats$Type extends MessageType<GroupStats> {
    constructor() {
        super('aegis.GroupStats', [
            { no: 1, name: 'gid', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: 'score', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: 'survivors_saved', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: 'correct_predictions', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: 'incorrect_predictions', kind: 'scalar', T: 5 /*ScalarType.INT32*/ }
        ])
    }
    create(value?: PartialMessage<GroupStats>): GroupStats {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.gid = 0
        message.name = ''
        message.score = 0
        message.survivorsSaved = 0
        message.correctPredictions = 0
        message.incorrectPredictions = 0
        if (value !== undefined) reflectionMergePartial<GroupStats>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GroupStats
    ): GroupStats {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* int32 gid */ 1:
                    message.gid = reader.int32()
                    break
                case /* string name */ 2:
                    message.name = reader.string()
                    break
                case /* int32 score */ 3:
                    message.score = reader.int32()
                    break
                case /* int32 survivors_saved */ 4:
                    message.survivorsSaved = reader.int32()
                    break
                case /* int32 correct_predictions */ 5:
                    message.correctPredictions = reader.int32()
                    break
                case /* int32 incorrect_predictions */ 6:
                    message.incorrectPredictions = reader.int32()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
            }
        }
        return message
    }
    internalBinaryWrite(message: GroupStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 gid = 1; */
        if (message.gid !== 0) writer.tag(1, WireType.Varint).int32(message.gid)
        /* string name = 2; */
        if (message.name !== '') writer.tag(2, WireType.LengthDelimited).string(message.name)
        /* int32 score = 3; */
        if (message.score !== 0) writer.tag(3, WireType.Varint).int32(message.score)
        /* int32 survivors_saved = 4; */
        if (message.survivorsSaved !== 0) writer.tag(4, WireType.Varint).int32(message.survivorsSaved)
        /* int32 correct_predictions = 5; */
        if (message.correctPredictions !== 0) writer.tag(5, WireType.Varint).int32(message.correctPredictions)
        /* int32 incorrect_predictions = 6; */
        if (message.incorrectPredictions !== 0) writer.tag(6, WireType.Varint).int32(message.incorrectPredictions)
        let u = options.writeUnknownFields
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
        return writer
    }
}
/**
 * @generated MessageType for protobuf message aegis.GroupStats
 */
export const GroupStats = new GroupStats$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RoundData$Type extends MessageType<RoundData> {
    constructor() {
        super('aegis.RoundData', [
            { no: 1, name: 'event_type', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: 'round', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: 'after_world', kind: 'message', T: () => WorldState },
            { no: 4, name: 'groups_data', kind: 'message', repeat: 2 /*RepeatType.UNPACKED*/, T: () => GroupData }
        ])
    }
    create(value?: PartialMessage<RoundData>): RoundData {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.eventType = ''
        message.round = 0
        message.groupsData = []
        if (value !== undefined) reflectionMergePartial<RoundData>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RoundData
    ): RoundData {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string event_type */ 1:
                    message.eventType = reader.string()
                    break
                case /* int32 round */ 2:
                    message.round = reader.int32()
                    break
                case /* aegis.WorldState after_world */ 3:
                    message.afterWorld = WorldState.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.afterWorld
                    )
                    break
                case /* repeated aegis.GroupData groups_data */ 4:
                    message.groupsData.push(GroupData.internalBinaryRead(reader, reader.uint32(), options))
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
            }
        }
        return message
    }
    internalBinaryWrite(message: RoundData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string event_type = 1; */
        if (message.eventType !== '') writer.tag(1, WireType.LengthDelimited).string(message.eventType)
        /* int32 round = 2; */
        if (message.round !== 0) writer.tag(2, WireType.Varint).int32(message.round)
        /* aegis.WorldState after_world = 3; */
        if (message.afterWorld)
            WorldState.internalBinaryWrite(
                message.afterWorld,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* repeated aegis.GroupData groups_data = 4; */
        for (let i = 0; i < message.groupsData.length; i++)
            GroupData.internalBinaryWrite(
                message.groupsData[i],
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
        return writer
    }
}
/**
 * @generated MessageType for protobuf message aegis.RoundData
 */
export const RoundData = new RoundData$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SimulationComplete$Type extends MessageType<SimulationComplete> {
    constructor() {
        super('aegis.SimulationComplete', [])
    }
    create(value?: PartialMessage<SimulationComplete>): SimulationComplete {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined) reflectionMergePartial<SimulationComplete>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SimulationComplete
    ): SimulationComplete {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
            }
        }
        return message
    }
    internalBinaryWrite(
        message: SimulationComplete,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        let u = options.writeUnknownFields
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
        return writer
    }
}
/**
 * @generated MessageType for protobuf message aegis.SimulationComplete
 */
export const SimulationComplete = new SimulationComplete$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SimulationEvent$Type extends MessageType<SimulationEvent> {
    constructor() {
        super('aegis.SimulationEvent', [
            { no: 1, name: 'world_init', kind: 'message', oneof: 'event', T: () => WorldState },
            { no: 2, name: 'round_update', kind: 'message', oneof: 'event', T: () => RoundUpdate },
            { no: 3, name: 'complete', kind: 'message', oneof: 'event', T: () => SimulationComplete }
        ])
    }
    create(value?: PartialMessage<SimulationEvent>): SimulationEvent {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.event = { oneofKind: undefined }
        if (value !== undefined) reflectionMergePartial<SimulationEvent>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SimulationEvent
    ): SimulationEvent {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* aegis.WorldState world_init */ 1:
                    message.event = {
                        oneofKind: 'worldInit',
                        worldInit: WorldState.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.event as any).worldInit
                        )
                    }
                    break
                case /* aegis.RoundUpdate round_update */ 2:
                    message.event = {
                        oneofKind: 'roundUpdate',
                        roundUpdate: RoundUpdate.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.event as any).roundUpdate
                        )
                    }
                    break
                case /* aegis.SimulationComplete complete */ 3:
                    message.event = {
                        oneofKind: 'complete',
                        complete: SimulationComplete.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.event as any).complete
                        )
                    }
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
            }
        }
        return message
    }
    internalBinaryWrite(message: SimulationEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* aegis.WorldState world_init = 1; */
        if (message.event.oneofKind === 'worldInit')
            WorldState.internalBinaryWrite(
                message.event.worldInit,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* aegis.RoundUpdate round_update = 2; */
        if (message.event.oneofKind === 'roundUpdate')
            RoundUpdate.internalBinaryWrite(
                message.event.roundUpdate,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* aegis.SimulationComplete complete = 3; */
        if (message.event.oneofKind === 'complete')
            SimulationComplete.internalBinaryWrite(
                message.event.complete,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
        return writer
    }
}
/**
 * @generated MessageType for protobuf message aegis.SimulationEvent
 */
export const SimulationEvent = new SimulationEvent$Type()
